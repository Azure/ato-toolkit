#!/usr/bin/env bash
# -*- coding: utf-8 -*-

# shellcheck source=src/runtime/bootstrap/lib/logging.sh
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && cd ../.. && pwd)/bootstrap/lib/logging.sh"

# shellcheck source=src/runtime/cluster-on-boarding/scripts/helpers.sh
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/helpers.sh"


flux_access_retries=10
flux_sleep_interval=10


function get_flux_ssh_keys() {

    if [[ $# -ne 2 ]]
    then
        error "Expecting 2 arguments for this function"
        return 1
    fi

    namespace="$1"
    releasename="$2"
    servicename="$releasename"

    # ensure the release is deployed before trying to get the services.
    counter=1
    status='unknown'
    while [ $counter -le $flux_access_retries ] && [[ ! "$status" == 'deployed' ]]
    do
        [ $counter -ge 2 ] && sleep $flux_sleep_interval
        info "Getting the status of the flux release $releasename"
        status=$(kubectl get -n "$namespace" helmreleases.helm.fluxcd.io "$releasename" -o jsonpath='{.status.releaseStatus}')
        counter=$(( counter + 1 ))
    done

    if  [[ ! $status == 'deployed' ]]; then
        error "Flux release failed, status $status"
        return 1
    fi

    # port-forward flux service to access the API that will give us the key
    info "Accessing flux api to retrieve ssh keys"
    kubectl -n "$namespace" --pod-running-timeout=2m0s port-forward service/"$servicename" 3030 &>/dev/null &

    # get the ssh key generated by flux by invoking the unprotected API, a POST to that url would force the regeneration of the key
    ssh_key_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/flux_id_rsa.pub"

    sleep 3
    curl -sS  http://localhost:3030/api/flux/v6/identity.pub | jq -r '.key' | tr -d '\n' > "$ssh_key_path"


    ini_val "$config_file" c12:generated.flux_ssh_key "$ssh_key_path"

    #kill the kubectl port-forward
    for job in $(jobs -l "%kubectl"  | cut -d' ' -f 2)
    do
        kill "$job"
    done
}
